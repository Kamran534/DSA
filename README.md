# Data Structures and Algorithms (DSA) Course Outline

## Course Overview
**Duration:** 12-16 weeks (3-4 months)  
**Level:** Beginner to Advanced  
**Prerequisites:** Basic programming knowledge in any language (Python/Java/C++ recommended)

---

## Module 1: Foundations and Complexity Analysis (Week 1-2)

### 1.1 Introduction to DSA
- What are Data Structures and Algorithms?
- Why DSA matters in software development
- Problem-solving approaches
- **Practice:** 5 basic problem-solving exercises

### 1.2 Time and Space Complexity
- Big O notation (O, Ω, Θ)
- Best, Average, and Worst case analysis
- Common time complexities: O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ)
- Space complexity analysis
- Amortized analysis basics
- **Practice:** 10 complexity analysis problems

### 1.3 Mathematical Foundations
- Logarithms and exponents
- Summations and series
- Recurrence relations
- Basic probability and combinatorics
- **Practice:** 8 mathematical problems

---

## Module 2: Arrays and Strings (Week 2-3)

### 2.1 Array Fundamentals
- Static vs Dynamic arrays
- Memory representation
- Basic operations: insertion, deletion, traversal
- 1D, 2D, and Multi-dimensional arrays
- **Practice:** 15 problems

### 2.2 Array Techniques
- Two-pointer technique
- Sliding window approach
- Prefix sum arrays
- Kadane's algorithm (Maximum subarray)
- Dutch National Flag problem
- **Practice:** 20 problems

### 2.3 String Manipulation
- String basics and immutability
- String matching algorithms (naive approach)
- Palindrome problems
- Anagram and substring problems
- String compression and transformation
- **Practice:** 20 problems

### 2.4 Advanced String Algorithms
- KMP (Knuth-Morris-Pratt) algorithm
- Rabin-Karp algorithm
- Z-algorithm
- Manacher's algorithm (longest palindromic substring)
- **Practice:** 10 problems

---

## Module 3: Linked Lists (Week 3-4)

### 3.1 Singly Linked Lists
- Node structure and implementation
- Insertion, deletion, search operations
- Reversal techniques
- Cycle detection (Floyd's algorithm)
- **Practice:** 15 problems

### 3.2 Doubly Linked Lists
- Implementation and operations
- Advantages over singly linked lists
- **Practice:** 8 problems

### 3.3 Circular Linked Lists
- Implementation and use cases
- **Practice:** 5 problems

### 3.4 Advanced Linked List Problems
- Merge sorted lists
- Intersection and union
- Flatten a multilevel linked list
- LRU Cache implementation
- **Practice:** 15 problems

---

## Module 4: Stacks and Queues (Week 4-5)

### 4.1 Stack Data Structure
- Array and linked list implementation
- Push, pop, peek operations
- Applications: parenthesis matching, expression evaluation
- **Practice:** 12 problems

### 4.2 Advanced Stack Problems
- Next greater/smaller element
- Stock span problem
- Largest rectangle in histogram
- Min stack implementation
- **Practice:** 15 problems

### 4.3 Queue Data Structure
- Array and linked list implementation
- Circular queue
- Deque (Double-ended queue)
- Priority queue introduction
- **Practice:** 12 problems

### 4.4 Queue Applications
- BFS prerequisite concepts
- Sliding window maximum
- Queue using stacks
- **Practice:** 10 problems

---

## Module 5: Recursion and Backtracking (Week 5-6)

### 5.1 Recursion Fundamentals
- Base case and recursive case
- Call stack visualization
- Tail recursion
- Recursion vs Iteration
- **Practice:** 15 problems

### 5.2 Common Recursive Patterns
- Linear recursion
- Binary recursion
- Multiple recursion
- Mutual recursion
- **Practice:** 12 problems

### 5.3 Backtracking Technique
- Backtracking framework
- State space tree
- Pruning strategies
- **Practice:** 20 problems

### 5.4 Classic Backtracking Problems
- N-Queens problem
- Sudoku solver
- Permutations and combinations
- Subset sum problem
- Word search
- Rat in a maze
- **Practice:** 20 problems

---

## Module 6: Sorting Algorithms (Week 6-7)

### 6.1 Elementary Sorting
- Bubble sort
- Selection sort
- Insertion sort
- Stability in sorting
- **Practice:** 10 problems

### 6.2 Efficient Sorting Algorithms
- Merge sort (divide and conquer)
- Quick sort and randomized quick sort
- Heap sort
- Comparison of sorting algorithms
- **Practice:** 15 problems

### 6.3 Special Sorting Algorithms
- Counting sort
- Radix sort
- Bucket sort
- When to use which algorithm
- **Practice:** 10 problems

### 6.4 Sorting Applications
- Custom comparators
- Sorting in different scenarios
- External sorting basics
- **Practice:** 12 problems

---

## Module 7: Searching Algorithms (Week 7)

### 7.1 Linear and Binary Search
- Linear search variations
- Binary search on sorted arrays
- Binary search variants (first/last occurrence)
- Binary search on answer
- **Practice:** 20 problems

### 7.2 Advanced Binary Search
- Search in rotated sorted array
- Peak element finding
- Square root and nth root
- Aggressive cows and similar problems
- **Practice:** 15 problems

### 7.3 Ternary Search
- Theory and implementation
- Applications in optimization
- **Practice:** 5 problems

---

## Module 8: Hashing (Week 8)

### 8.1 Hash Table Fundamentals
- Hash functions
- Collision resolution (chaining, open addressing)
- Load factor and rehashing
- **Practice:** 10 problems

### 8.2 Hash Map and Hash Set
- Implementation details
- Common operations and complexity
- Applications in problem-solving
- **Practice:** 20 problems

### 8.3 Advanced Hashing Problems
- Two sum, three sum, four sum
- Longest consecutive sequence
- Subarray with given sum
- Count distinct elements in window
- **Practice:** 20 problems

---

## Module 9: Trees - Part 1 (Week 8-9)

### 9.1 Binary Tree Basics
- Tree terminology
- Tree representation
- Tree traversals (inorder, preorder, postorder)
- Level order traversal
- **Practice:** 15 problems

### 9.2 Binary Tree Properties
- Height and depth
- Diameter of tree
- Balanced vs unbalanced trees
- Full, complete, perfect binary trees
- **Practice:** 15 problems

### 9.3 Binary Tree Construction
- Construct from traversals
- Serialize and deserialize
- Clone and copy
- **Practice:** 12 problems

### 9.4 Binary Tree Advanced
- Lowest common ancestor (LCA)
- Path problems
- View problems (top, bottom, left, right)
- Boundary traversal
- **Practice:** 20 problems

---

## Module 10: Trees - Part 2 (Week 9-10)

### 10.1 Binary Search Trees (BST)
- BST properties
- Search, insertion, deletion
- BST validation
- **Practice:** 15 problems

### 10.2 BST Advanced Problems
- Kth smallest/largest element
- Two sum in BST
- Pair with given sum
- Convert sorted array/list to BST
- **Practice:** 15 problems

### 10.3 Balanced BSTs
- AVL trees (concepts)
- Red-Black trees (concepts)
- Self-balancing importance
- **Practice:** 5 problems

### 10.4 Special Trees
- Trie (Prefix tree) - detailed coverage
- Segment tree - introduction
- Fenwick tree (Binary Indexed Tree) - introduction
- **Practice:** 15 problems

---

## Module 11: Heaps and Priority Queues (Week 10-11)

### 11.1 Heap Fundamentals
- Min heap and max heap
- Heap representation (array)
- Heapify operation
- Heap sort revisited
- **Practice:** 10 problems

### 11.2 Priority Queue Operations
- Insert and extract operations
- Increase/decrease key
- Priority queue implementation
- **Practice:** 8 problems

### 11.3 Heap Applications
- Kth largest/smallest element
- Merge K sorted lists/arrays
- Top K frequent elements
- Median in a stream
- **Practice:** 20 problems

### 11.4 Advanced Heap Problems
- Connect n ropes with minimum cost
- Sliding window median
- Reorganize string
- **Practice:** 10 problems

---

## Module 12: Graphs - Part 1 (Week 11-12)

### 12.1 Graph Fundamentals
- Graph representation (adjacency matrix, adjacency list)
- Types of graphs (directed, undirected, weighted, unweighted)
- Graph terminology (vertices, edges, degree, path, cycle)
- **Practice:** 8 problems

### 12.2 Graph Traversal
- Breadth-First Search (BFS)
- Depth-First Search (DFS)
- Connected components
- Topological sorting (DFS and Kahn's algorithm)
- **Practice:** 20 problems

### 12.3 Cycle Detection
- Cycle in undirected graphs
- Cycle in directed graphs
- **Practice:** 10 problems

### 12.4 Bipartite Graphs
- Bipartite check using BFS/DFS
- Graph coloring basics
- **Practice:** 8 problems

---

## Module 13: Graphs - Part 2 (Week 12-13)

### 13.1 Shortest Path Algorithms
- BFS for unweighted graphs
- Dijkstra's algorithm (single source)
- Bellman-Ford algorithm (negative weights)
- Floyd-Warshall algorithm (all pairs)
- **Practice:** 15 problems

### 13.2 Minimum Spanning Tree
- Prim's algorithm
- Kruskal's algorithm
- Disjoint Set Union (Union-Find)
- **Practice:** 12 problems

### 13.3 Advanced Graph Algorithms
- Bridges and articulation points
- Strongly connected components (Kosaraju's, Tarjan's)
- Eulerian path and circuit
- Hamiltonian path (basics)
- **Practice:** 15 problems

### 13.4 Special Graph Problems
- Network flow basics
- Maximum bipartite matching
- Graph cloning
- Word ladder problems
- **Practice:** 10 problems

---

## Module 14: Dynamic Programming - Part 1 (Week 13-14)

### 14.1 DP Fundamentals
- What is dynamic programming?
- Overlapping subproblems
- Optimal substructure
- Memoization vs Tabulation
- **Practice:** 10 problems

### 14.2 1D DP Problems
- Fibonacci and variations
- Climbing stairs
- House robber
- Maximum sum non-adjacent elements
- Jump game
- **Practice:** 15 problems

### 14.3 2D DP Problems
- Grid path problems
- Minimum path sum
- Unique paths
- Longest common subsequence (LCS)
- Edit distance
- **Practice:** 20 problems

### 14.4 String DP
- Longest palindromic subsequence
- Palindrome partitioning
- Wildcard pattern matching
- Regular expression matching
- **Practice:** 15 problems

---

## Module 15: Dynamic Programming - Part 2 (Week 14-15)

### 15.1 Knapsack Problems
- 0/1 Knapsack
- Unbounded knapsack
- Subset sum
- Partition equal subset sum
- Target sum
- **Practice:** 15 problems

### 15.2 DP on Subsequences
- Longest increasing subsequence (LIS)
- Russian doll envelopes
- Number of LIS
- Maximum length chain
- **Practice:** 12 problems

### 15.3 DP on Stocks
- Best time to buy and sell stock (all variations)
- With cooldown, with transaction fee
- **Practice:** 10 problems

### 15.4 DP on Trees
- Diameter of tree
- Maximum path sum
- House robber III
- **Practice:** 10 problems

### 15.5 Advanced DP
- Matrix chain multiplication
- Egg dropping problem
- Word break problem
- Burst balloons
- **Practice:** 15 problems

---

## Module 16: Greedy Algorithms (Week 15)

### 16.1 Greedy Technique
- Greedy approach vs DP
- When to use greedy
- Proving greedy correctness
- **Practice:** 8 problems

### 16.2 Classic Greedy Problems
- Activity selection
- Fractional knapsack
- Job sequencing
- Huffman coding
- **Practice:** 15 problems

### 16.3 Interval Problems
- Merge intervals
- Insert interval
- Non-overlapping intervals
- Meeting rooms
- **Practice:** 12 problems

### 16.4 Advanced Greedy
- Jump game II
- Gas station
- Candy distribution
- Minimum platforms
- **Practice:** 12 problems

---

## Module 17: Advanced Topics (Week 16)

### 17.1 Bit Manipulation
- Bitwise operators
- Common bit tricks
- Subset generation using bits
- XOR properties and problems
- **Practice:** 20 problems

### 17.2 Mathematical Algorithms
- Prime numbers (Sieve of Eratosthenes)
- GCD and LCM (Euclidean algorithm)
- Modular arithmetic
- Fast exponentiation
- **Practice:** 15 problems

### 17.3 Two Pointer and Sliding Window Revisited
- Advanced two-pointer problems
- Complex sliding window scenarios
- **Practice:** 15 problems

### 17.4 Design Problems
- LRU Cache
- LFU Cache
- Design Twitter
- Design data structures
- **Practice:** 10 problems

---

## Module 18: Problem-Solving Strategies and Practice (Ongoing)

### 18.1 Pattern Recognition
- Common problem patterns
- How to identify which technique to use
- Problem classification

### 18.2 Optimization Techniques
- Time-space tradeoffs
- When to optimize
- Refactoring approaches

### 18.3 Mock Interviews
- Timed problem-solving
- Communication during coding
- Handling hints and feedback

### 18.4 Company-Specific Preparation
- FAANG-style problems
- Startup-style problems
- Product-based vs service-based companies

---

## Assessment Strategy

### Weekly Assignments
- 20-30 problems per week
- Mix of easy, medium, and hard problems
- Peer code review sessions

### Monthly Tests
- 2-hour timed assessments
- 3-4 problems of varying difficulty
- Performance analysis and feedback

### Final Project
- Build a complex application using multiple DSA concepts
- Examples: File system, social network analyzer, route optimizer
- Code documentation and presentation

---

## Recommended Practice Platforms

1. **LeetCode** (Primary platform)
   - 300+ problems minimum
   - Focus on medium and hard problems

2. **GeeksforGeeks**
   - Detailed explanations
   - Topic-wise practice

3. **Codeforces** (Optional)
   - Competitive programming
   - Contest participation

4. **HackerRank**
   - Interview preparation kit
   - Company-specific practice

5. **InterviewBit**
   - Structured learning path
   - Mock interviews

---

## Learning Resources

### Books
- "Introduction to Algorithms" by CLRS
- "Data Structures and Algorithms Made Easy" by Narasimha Karumanchi
- "Cracking the Coding Interview" by Gayle Laakmann McDowell
- "Algorithm Design Manual" by Steven Skiena

### Online Courses
- MIT OCW 6.006 (Introduction to Algorithms)
- Stanford CS161 (Design and Analysis of Algorithms)
- Coursera - Algorithms Specialization

### YouTube Channels
- Abdul Bari (Theory)
- NeetCode (Problem-solving)
- take U forward (Comprehensive)
- Back To Back SWE

---

## Daily Study Plan

### Beginner Phase (Week 1-6)
- 2-3 hours daily
- 5-8 problems per day
- Focus on understanding concepts

### Intermediate Phase (Week 7-12)
- 3-4 hours daily
- 8-10 problems per day
- Balance between learning and practice

### Advanced Phase (Week 13-16)
- 4-5 hours daily
- 10-15 problems per day
- Focus on hard problems and optimization

---

## Success Metrics

### By End of Course
- ✓ 500+ problems solved
- ✓ Strong foundation in all DSA topics
- ✓ Ability to solve medium problems independently
- ✓ 60%+ hard problems solvable with hints
- ✓ Interview-ready for top tech companies

### Skills Acquired
- Problem decomposition
- Algorithmic thinking
- Code optimization
- Time/space complexity analysis
- Technical communication
- Debugging complex algorithms

---

## Tips for Success

1. **Consistency is Key**
   - Practice daily without breaks
   - Regular > Intensive cramming

2. **Understand, Don't Memorize**
   - Focus on patterns and intuition
   - Implement from scratch

3. **Track Your Progress**
   - Maintain a problem-solving journal
   - Review mistakes weekly

4. **Active Learning**
   - Explain concepts to others
   - Write your own explanations

5. **Participate in Communities**
   - Join study groups
   - Engage in forums and discussions

6. **Mock Interviews**
   - Practice with peers weekly
   - Get comfortable thinking aloud

---

## Next Steps After Course

1. **Continue Daily Practice**
   - Maintain solving 2-3 problems daily
   - Participate in weekly contests

2. **Contribute to Open Source**
   - Apply DSA knowledge in real projects

3. **Deep Dive Specialization**
   - Machine Learning Algorithms
   - System Design
   - Competitive Programming

4. **Mentor Others**
   - Teaching reinforces learning
   - Help beginners in communities

---

**Remember:** DSA mastery is a marathon, not a sprint. Focus on consistent progress, and you'll see tremendous growth over time!

**Total Practice Problems:** 800+ across all modules  
**Course Intensity:** High  
**Expected Outcome:** Interview-ready for top tech companies